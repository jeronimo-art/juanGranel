"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertActions = exports.duplicateCell = exports.duplicateNode = exports.insertCellNewAsNewRow = exports.insertCellAtTheEnd = exports.insertCellRightInline = exports.insertCellLeftInline = exports.insertCellLeftOf = exports.insertCellRightOf = exports.insertCellAbove = exports.insertCellBelow = exports.createCell = exports.createRow = exports.CELL_INSERT_AS_NEW_ROW = exports.CELL_INSERT_AT_END = exports.CELL_INSERT_INLINE_RIGHT = exports.CELL_INSERT_INLINE_LEFT = exports.CELL_INSERT_RIGHT_OF = exports.CELL_INSERT_LEFT_OF = exports.CELL_INSERT_BELOW = exports.CELL_INSERT_ABOVE = void 0;
var cloneWithNewIds_1 = require("../../../core/utils/cloneWithNewIds");
var types_1 = require("../../types");
var createId_1 = require("../../utils/createId");
var getAvailablePlugins_1 = require("../../utils/getAvailablePlugins");
var getCellData_1 = require("../../utils/getCellData");
var removeUndefinedProps_1 = require("../../utils/removeUndefinedProps");
var display_1 = require("../display");
var helpers_1 = require("../helpers");
var core_1 = require("./core");
exports.CELL_INSERT_ABOVE = 'CELL_INSERT_ABOVE';
exports.CELL_INSERT_BELOW = 'CELL_INSERT_BELOW';
exports.CELL_INSERT_LEFT_OF = 'CELL_INSERT_LEFT_OF';
exports.CELL_INSERT_RIGHT_OF = 'CELL_INSERT_RIGHT_OF';
exports.CELL_INSERT_INLINE_LEFT = 'CELL_INSERT_INLINE_LEFT';
exports.CELL_INSERT_INLINE_RIGHT = 'CELL_INSERT_INLINE_RIGHT';
exports.CELL_INSERT_AT_END = 'CELL_INSERT_AT_END';
exports.CELL_INSERT_AS_NEW_ROW = 'CELL_INSERT_AS_NEW_ROW';
var createRow = function (partialRow, options) {
    var _a;
    if (Array.isArray(partialRow)) {
        return {
            id: (0, createId_1.createId)(),
            cells: partialRow.map(function (c) { return (0, exports.createCell)(c, options); }),
        };
    }
    return (0, removeUndefinedProps_1.removeUndefinedProps)(__assign(__assign({ id: (0, createId_1.createId)() }, partialRow), { cells: (_a = partialRow.cells) === null || _a === void 0 ? void 0 : _a.map(function (c) { return (0, exports.createCell)(c, options); }) }));
};
exports.createRow = createRow;
var createCell = function (partialCell, options) {
    var _a;
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var cellPlugins = options.cellPlugins, lang = options.lang;
    var pluginId = partialCell.plugin &&
        (typeof partialCell.plugin == 'string'
            ? partialCell.plugin
            : partialCell.plugin.id);
    var plugin = pluginId && cellPlugins.find(function (p) { return p.id === pluginId; });
    var partialRows = ((_b = partialCell.rows) === null || _b === void 0 ? void 0 : _b.length) > 0
        ? partialCell.rows
        : (_d = (_c = plugin === null || plugin === void 0 ? void 0 : plugin.createInitialChildren) === null || _c === void 0 ? void 0 : _c.call(plugin)) !== null && _d !== void 0 ? _d : [];
    var dataI18n = __assign((_a = {}, _a[lang] = (_j = (_g = (_e = partialCell === null || partialCell === void 0 ? void 0 : partialCell.data) !== null && _e !== void 0 ? _e : (_f = plugin === null || plugin === void 0 ? void 0 : plugin.createInitialData) === null || _f === void 0 ? void 0 : _f.call(plugin, partialCell)) !== null && _g !== void 0 ? _g : (_h = plugin === null || plugin === void 0 ? void 0 : plugin.createInitialState) === null || _h === void 0 ? void 0 : _h.call(plugin, partialCell)) !== null && _j !== void 0 ? _j : null, _a), ((_k = partialCell.dataI18n) !== null && _k !== void 0 ? _k : {}));
    return (0, removeUndefinedProps_1.removeUndefinedProps)({
        id: (_l = partialCell.id) !== null && _l !== void 0 ? _l : (0, createId_1.createId)(),
        isDraft: partialCell.isDraft,
        isDraftI18n: partialCell.isDraftI18n,
        inline: partialCell.inline,
        size: partialCell.size || 12,
        hasInlineNeighbour: partialCell.hasInlineNeighbour,
        plugin: plugin
            ? {
                id: plugin.id,
                version: plugin.version,
            }
            : undefined,
        rows: partialRows === null || partialRows === void 0 ? void 0 : partialRows.map(function (r) {
            return (0, exports.createRow)(r, {
                lang: lang,
                cellPlugins: (0, getAvailablePlugins_1.getChildCellPlugins)(cellPlugins, {
                    pluginId: pluginId,
                    data: (0, getCellData_1.getCellData)({
                        dataI18n: dataI18n,
                    }, lang),
                }),
            });
        }),
        dataI18n: dataI18n,
    });
};
exports.createCell = createCell;
var insert = function (type) {
    return function (options) {
        return function (partialCell, target, insertOptions, ids) {
            if (ids === void 0) { ids = (0, helpers_1.generateIds)(); }
            var cell = (0, exports.createCell)(partialCell, options);
            var isNew = !partialCell.id;
            return insertFullCell(type)(cell, target, __assign(__assign({}, insertOptions), { focusAfter: (insertOptions === null || insertOptions === void 0 ? void 0 : insertOptions.focusAfter) || isNew }), ids);
        };
    };
};
var insertFullCell = function (type) {
    return function (cell, _a, insertOptions, ids) {
        var _b, _c;
        var hoverId = _a.id, inline = _a.inline, hasInlineNeighbour = _a.hasInlineNeighbour, ancestorIds = _a.ancestorIds;
        if (ids === void 0) { ids = (0, helpers_1.generateIds)(); }
        var level = (_b = insertOptions === null || insertOptions === void 0 ? void 0 : insertOptions.level) !== null && _b !== void 0 ? _b : 0;
        var l = level;
        switch (type) {
            case exports.CELL_INSERT_ABOVE:
            case exports.CELL_INSERT_BELOW: {
                if ((inline || hasInlineNeighbour) && level < 1) {
                    l = 1;
                }
                break;
            }
            case exports.CELL_INSERT_LEFT_OF:
            case exports.CELL_INSERT_RIGHT_OF: {
                if ((inline || hasInlineNeighbour) && level < 1) {
                    l = 1;
                }
                break;
            }
            default:
        }
        var insertAction = {
            type: type,
            ts: new Date(),
            item: cell,
            hoverId: level === 0 ? hoverId : (_c = ancestorIds[Math.max(level - 1)]) !== null && _c !== void 0 ? _c : hoverId,
            level: l,
            // FIXME: item handling is a bit confusing,
            // we now give some of them a name like "cell" or "item",
            // but the purpose of the others is unclear
            ids: ids,
            notUndoable: insertOptions.notUndoable,
        };
        return function (dispatch) {
            dispatch(insertAction);
            if (insertOptions === null || insertOptions === void 0 ? void 0 : insertOptions.focusAfter) {
                dispatch((0, display_1.editMode)());
                setTimeout(function () {
                    var _a, _b, _c, _d, _e;
                    dispatch((0, core_1.focusCell)(
                    // first condition is for pasted cells. I know its a bit weird
                    (_e = (_d = (_c = (_b = (_a = cell.rows) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.cells) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.id) !== null && _e !== void 0 ? _e : insertAction.ids.item, true));
                }, 0);
            }
        };
    };
};
/**
 * Insert a cell below of the hovering cell.
 */
exports.insertCellBelow = insert(exports.CELL_INSERT_BELOW);
/**
 * Insert a cell above of the hovering cell.
 */
exports.insertCellAbove = insert(exports.CELL_INSERT_ABOVE);
/**
 * Insert a cell right of the hovering cell.
 */
exports.insertCellRightOf = insert(exports.CELL_INSERT_RIGHT_OF);
/**
 * Insert a cell left of the hovering cell.
 */
exports.insertCellLeftOf = insert(exports.CELL_INSERT_LEFT_OF);
/**
 * Insert a cell inside the hovering cell, on the left.
 */
exports.insertCellLeftInline = insert(exports.CELL_INSERT_INLINE_LEFT);
/**
 * Insert a cell inside the hovering cell, on the right.
 */
exports.insertCellRightInline = insert(exports.CELL_INSERT_INLINE_RIGHT);
exports.insertCellAtTheEnd = insert(exports.CELL_INSERT_AT_END);
exports.insertCellNewAsNewRow = insert(exports.CELL_INSERT_AS_NEW_ROW);
var duplicateNode = function (node, options) {
    var cell = (0, types_1.isRow)(node)
        ? {
            id: (0, createId_1.createId)(),
            rows: [node],
        }
        : node;
    return (0, exports.duplicateCell)(cell, options);
};
exports.duplicateNode = duplicateNode;
var duplicateCell = function (item, options) {
    var _a, _b;
    var cellWithNewIds = (0, cloneWithNewIds_1.cloneWithNewIds)(item);
    var action = insertFullCell(exports.CELL_INSERT_BELOW)(cellWithNewIds, {
        ancestorIds: [],
        id: (_a = options === null || options === void 0 ? void 0 : options.insertAfterNodeId) !== null && _a !== void 0 ? _a : item.id,
        hasInlineNeighbour: item.hasInlineNeighbour,
        inline: item.inline,
        levels: null,
        pluginId: (_b = item.plugin) === null || _b === void 0 ? void 0 : _b.id,
    }, {
        level: 0,
        focusAfter: true,
    });
    return action;
};
exports.duplicateCell = duplicateCell;
exports.insertActions = {
    insertCellRightInline: exports.insertCellRightInline,
    insertCellLeftInline: exports.insertCellLeftInline,
    insertCellLeftOf: exports.insertCellLeftOf,
    insertCellRightOf: exports.insertCellRightOf,
    insertCellAbove: exports.insertCellAbove,
    insertCellBelow: exports.insertCellBelow,
    duplicateCell: exports.duplicateCell,
    insertCellAtTheEnd: exports.insertCellAtTheEnd,
    insert: insert,
};
//# sourceMappingURL=insert.js.map