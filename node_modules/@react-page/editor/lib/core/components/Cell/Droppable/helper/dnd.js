"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onDrop = exports.onHover = void 0;
var lodash_throttle_1 = __importDefault(require("lodash.throttle"));
var throttle_1 = require("../../../../helper/throttle");
var input_1 = require("../../../../service/hover/input");
var logger_1 = __importDefault(require("../../../../service/logger"));
var last = { hoverId: '', dragId: '' };
var shouldClear = function (hoverId, dragId) {
    if (hoverId === last.hoverId && dragId === last.dragId) {
        return false;
    }
    last = { hoverId: hoverId, dragId: dragId };
    return true;
};
exports.onHover = (0, lodash_throttle_1.default)(function (target, monitor, element, actions, cellPlugins) {
    var drag = monitor.getItem();
    if (!drag || !target) {
        // item undefined, happens when throttle triggers after drop
        return;
    }
    if (drag.cell.id === target.id) {
        // If hovering over itself, do nothing
        if (shouldClear(target.id, drag.cell.id)) {
            actions.clear();
        }
        return;
    }
    else if (!monitor.isOver({ shallow: true })) {
        // If hovering over ancestor cell, do nothing (we are going to propagate later in the tree anyways)
        return;
    }
    else if (target.ancestorIds.includes(drag.cell.id)) {
        if (shouldClear(target.id, drag.cell.id)) {
            actions.clear();
        }
        return;
    }
    else if (!target.id) {
        // If hovering over something that isn't a cell or hasn't an id, do nothing. Should be an edge case
        logger_1.default.warn('Canceled cell drop, no id given.', target, drag);
        return;
    }
    last = { hoverId: target.id, dragId: drag.cell.id };
    (0, input_1.computeAndDispatchHover)(target, drag.cell, monitor, element, actions, cellPlugins);
}, throttle_1.delay, { leading: false });
var onDrop = function (target, monitor, element, actions, cellPlugins) {
    var drag = monitor.getItem();
    if (monitor.didDrop() || !monitor.isOver({ shallow: true }) || !target) {
        // If the item drop occurred deeper down the tree, don't do anything
        return;
    }
    else if (drag.cell.id === target.id) {
        // If the item being dropped on itself do nothing
        actions.cancelCellDrag();
        return;
    }
    else if (target.ancestorIds.includes(drag.cell.id)) {
        // If hovering over a child of itself, don't propagate further
        actions.cancelCellDrag();
        return;
    }
    last = { hoverId: target.id, dragId: drag.cell.id };
    (0, input_1.computeAndDispatchInsert)(target, drag.cell, monitor, element, actions, cellPlugins);
};
exports.onDrop = onDrop;
//# sourceMappingURL=dnd.js.map