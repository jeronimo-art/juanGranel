"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDropActions = exports.useHoverActions = void 0;
var react_1 = require("react");
var cell_1 = require("../../actions/cell");
var insert_1 = require("../../actions/cell/insert");
var reduxConnect_1 = require("../../reduxConnect");
var node_1 = require("./node");
var options_1 = require("./options");
/**
 * @returns object of actions for hovering
 */
var useHoverActions = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    return (0, react_1.useMemo)(function () { return ({
        dragCell: function (id) { return dispatch((0, cell_1.dragCell)(id)); },
        clear: function () { return dispatch((0, cell_1.clearHover)()); },
        cancelCellDrag: function () { return dispatch((0, cell_1.cancelCellDrag)()); },
        above: function (drag, hover, options) {
            return dispatch((0, cell_1.cellHoverAbove)(drag, hover, options === null || options === void 0 ? void 0 : options.level));
        },
        below: function (drag, hover, options) {
            return dispatch((0, cell_1.cellHoverBelow)(drag, hover, options === null || options === void 0 ? void 0 : options.level));
        },
        leftOf: function (drag, hover, options) {
            return dispatch((0, cell_1.cellHoverLeftOf)(drag, hover, options === null || options === void 0 ? void 0 : options.level));
        },
        rightOf: function (drag, hover, options) {
            return dispatch((0, cell_1.cellHoverRightOf)(drag, hover, options === null || options === void 0 ? void 0 : options.level));
        },
        inlineLeft: function (drag, hover) { return dispatch((0, cell_1.cellHoverInlineLeft)(drag, hover)); },
        inlineRight: function (drag, hover) { return dispatch((0, cell_1.cellHoverInlineRight)(drag, hover)); },
    }); }, [dispatch]);
};
exports.useHoverActions = useHoverActions;
/**
 * @param nodeId the parent reference node id
 * @returns object of actions for dropping a cell
 */
var useDropActions = function (parentNodeId) {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    var lang = (0, options_1.useLang)();
    var cellPlugins = (0, node_1.useAllCellPluginsForNode)(parentNodeId);
    return (0, react_1.useMemo)(function () { return ({
        above: function (drag, hover, level) {
            return dispatch((0, insert_1.insertCellAbove)({ cellPlugins: cellPlugins, lang: lang })(drag, hover, level));
        },
        below: function (drag, hover, level) {
            return dispatch((0, insert_1.insertCellBelow)({ cellPlugins: cellPlugins, lang: lang })(drag, hover, level));
        },
        leftOf: function (drag, hover, level) {
            return dispatch((0, insert_1.insertCellLeftOf)({ cellPlugins: cellPlugins, lang: lang })(drag, hover, level));
        },
        rightOf: function (drag, hover, level) {
            return dispatch((0, insert_1.insertCellRightOf)({ cellPlugins: cellPlugins, lang: lang })(drag, hover, level));
        },
        inlineLeft: function (drag, hover) {
            return dispatch((0, insert_1.insertCellLeftInline)({ cellPlugins: cellPlugins, lang: lang })(drag, hover));
        },
        inlineRight: function (drag, hover) {
            return dispatch((0, insert_1.insertCellRightInline)({ cellPlugins: cellPlugins, lang: lang })(drag, hover));
        },
        dragCell: function (id) { return dispatch((0, cell_1.dragCell)(id)); },
        clear: function () { return dispatch((0, cell_1.clearHover)()); },
        cancelCellDrag: function () { return dispatch((0, cell_1.cancelCellDrag)()); },
    }); }, [dispatch, lang, cellPlugins]);
};
exports.useDropActions = useDropActions;
//# sourceMappingURL=dragDropActions.js.map