"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useScrollToViewEffect = exports.useIsExclusivlyFocused = exports.useIsFocused = exports.useAllFocusedNodeIds = exports.useFocusedNodeId = void 0;
var react_1 = require("react");
var reduxConnect_1 = require("../../reduxConnect");
var focus_1 = require("../../selector/focus");
/**
 * @returns the current focused nodeId if just one or null
 */
var useFocusedNodeId = function () {
    return (0, reduxConnect_1.useSelector)(focus_1.singleFocusedNode);
};
exports.useFocusedNodeId = useFocusedNodeId;
var useAllFocusedNodeIds = function () {
    return (0, reduxConnect_1.useSelector)(focus_1.allFocusedNodeIds);
};
exports.useAllFocusedNodeIds = useAllFocusedNodeIds;
/**
 *
 * @param id the id of the node (row/cell)
 * @returns true if the given node id is focused
 */
var useIsFocused = function (id) {
    return (0, reduxConnect_1.useSelector)(function (state) { return (0, focus_1.allFocusedNodeIds)(state).includes(id); });
};
exports.useIsFocused = useIsFocused;
/**
 *
 * @param id the id of the node (row/cell)
 * @returns true if ONLY the given node id is focused
 */
var useIsExclusivlyFocused = function (id) {
    return (0, reduxConnect_1.useSelector)(function (state) { return (0, focus_1.singleFocusedNode)(state) === id; });
};
exports.useIsExclusivlyFocused = useIsExclusivlyFocused;
/**
 *
 * @param id the id of the node
 * @param effect callback that is run when the given node is focused and the focus action demanded scrollToCell
 * @param deps effect deps array
 */
var useScrollToViewEffect = function (id, effect, deps) {
    var scrollToCell = (0, reduxConnect_1.useSelector)(function (state) {
        var f = (0, focus_1.focus)(state);
        var nodeId = (0, focus_1.singleFocusedNode)(state);
        if (!f || nodeId !== id) {
            return null;
        }
        return f.scrollToCell;
    });
    (0, react_1.useEffect)(function () {
        if (scrollToCell) {
            return effect();
        }
    }, __spreadArray([scrollToCell], __read(deps), false));
};
exports.useScrollToViewEffect = useScrollToViewEffect;
//# sourceMappingURL=focus.js.map