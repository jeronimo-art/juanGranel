"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDebouncedCellData = exports.useCellInnerDivStylingProps = exports.useCellData = exports.useCellDataI18nRaw = exports.usePluginOfCell = exports.useCellIsAllowedHere = exports.useAllCellPluginsForNode = exports.useCellHasPlugin = exports.useNodeHasChildren = exports.useNodeChildrenIds = exports.useCellBounds = exports.useNodeAsHoverTarget = exports.useParentCellId = exports.useNodeAncestorIds = exports.useNodeHoverPosition = exports.useRowProps = exports.useCell = exports.useCellProps = exports.useNodeAncestorProps = exports.useNodeProps = void 0;
var lodash_debounce_1 = __importDefault(require("lodash.debounce"));
var react_1 = require("react");
var reduxConnect_1 = require("../../reduxConnect");
var editable_1 = require("../../selector/editable");
var node_1 = require("../../types/node");
var deepEquals_1 = __importDefault(require("../../utils/deepEquals"));
var getAvailablePlugins_1 = require("../../utils/getAvailablePlugins");
var getCellData_1 = require("../../utils/getCellData");
var getCellStylingProps_1 = require("../../utils/getCellStylingProps");
var getDropLevels_1 = require("../../utils/getDropLevels");
var nodeActions_1 = require("./nodeActions");
var options_1 = require("./options");
var renderOptions_1 = require("./renderOptions");
/**
 * Use this function to get derived properties of a node. It prevents unnessesary rerenders when only the nessesary properties are returned by the selector
 *
 * you can also select props from the ancestors of the node. Be aware that the last ancestor is the root document id
 *
 * @param nodeId an id of a node (cell or row)
 * @param selector receives the node object or null (if no node with this id exists) and returns T
 * @returns the selection T
 */
var useNodeProps = function (nodeId, selector) {
    var node = (0, reduxConnect_1.useSelector)(function (state) {
        var result = (0, editable_1.findNodeInState)(state, nodeId);
        if (!result) {
            return selector(null, []);
        }
        return selector(result.node, result.ancestors);
    }, deepEquals_1.default);
    return node;
};
exports.useNodeProps = useNodeProps;
/**
 *
 * @param nodeId id of a node
 * @param selector receives the ancestors array and returns T
 * @returns T
 */
var useNodeAncestorProps = function (nodeId, selector) {
    return (0, exports.useNodeProps)(nodeId, function (__, ancestors) { return selector(ancestors); });
};
exports.useNodeAncestorProps = useNodeAncestorProps;
/**
 * This is the same as @see useNodeProps, but only for cells. selector will receive null if the given nodeId is not a cell
 * @param nodeId an id of a cell
 * @param selector receives the cell or null (if no cell with this id exists) object and returns T
 * @returns the selection T
 */
var useCellProps = function (nodeId, selector) {
    if (!nodeId) {
        return null;
    }
    return (0, exports.useNodeProps)(nodeId, function (node, ancestors) {
        return node && !(0, node_1.isRow)(node) ? selector(node, ancestors) : selector(null, ancestors);
    });
};
exports.useCellProps = useCellProps;
/**
 * better use useCellProps, unless you really need the full cell object
 * @param nodeId an id of a cell
 * @returns full Cell object
 */
var useCell = function (nodeId) {
    return (0, exports.useNodeProps)(nodeId, function (node, ancestors) {
        return !(0, node_1.isRow)(node) ? node : null;
    });
};
exports.useCell = useCell;
/**
 * This is the same as @see useNodeProps, but only for rows.
 * @param nodeId an id of a row
 * @param selector receives the row or null (if no row with this id exists) object and returns T
 * @returns the selection T
 */
var useRowProps = function (nodeId, selector) {
    return (0, exports.useNodeProps)(nodeId, function (node, ancestors) {
        return (0, node_1.isRow)(node) ? selector(node, ancestors) : null;
    });
};
exports.useRowProps = useRowProps;
/**
 *
 * @param nodeId id of a node
 * @returns the relative hover position over the given node, or null if this node is not hovered over
 */
var useNodeHoverPosition = function (nodeId) {
    return (0, reduxConnect_1.useSelector)(function (state) {
        var _a, _b;
        return ((_a = state.reactPage.hover) === null || _a === void 0 ? void 0 : _a.nodeId) === nodeId
            ? (_b = state.reactPage.hover) === null || _b === void 0 ? void 0 : _b.position
            : null;
    });
};
exports.useNodeHoverPosition = useNodeHoverPosition;
/**
 *
 * @param nodeId id of a node
 * @returns an array of ids that are ancestors of the given node
 */
var useNodeAncestorIds = function (nodeId) {
    return (0, exports.useNodeAncestorProps)(nodeId, function (ancestors) {
        return ancestors.map(function (a) { return a.id; });
    });
};
exports.useNodeAncestorIds = useNodeAncestorIds;
/**
 *
 * @param nodeId the id of a row or cell
 * @returns the nearest ancestor cell of the cell or row that has a plugin
 */
var useParentCellId = function (nodeId) {
    return (0, exports.useNodeProps)(nodeId, function (node, ancestors) {
        var _a;
        return node && ancestors
            ? (_a = ancestors.find(function (node) { return !(0, node_1.isRow)(node) && node.plugin; })) === null || _a === void 0 ? void 0 : _a.id
            : null;
    });
};
exports.useParentCellId = useParentCellId;
/**
 * returns a cell as a HoverTarget that is suiteable to be passed to the drop-logic
 *
 * @param nodeId a nodeId
 * @returns a HoverTarget
 */
var useNodeAsHoverTarget = function (nodeId) {
    return (0, exports.useNodeProps)(nodeId, function (node, ancestors) {
        var _a;
        return node
            ? {
                id: node.id,
                // the last element is the root element, we can't currenly use that as hover target
                ancestorIds: ancestors.slice(0, -1).map(function (a) { return a.id; }),
                hasInlineNeighbour: !(0, node_1.isRow)(node) ? node.hasInlineNeighbour : null,
                inline: !(0, node_1.isRow)(node) ? node.inline : null,
                levels: (0, getDropLevels_1.getDropLevels)(node, ancestors),
                pluginId: !(0, node_1.isRow)(node) ? (_a = node.plugin) === null || _a === void 0 ? void 0 : _a.id : null,
            }
            : null;
    });
};
exports.useNodeAsHoverTarget = useNodeAsHoverTarget;
/**
 *
 * @deprecated currently unused
 */
var useCellBounds = function (nodeId) {
    return (0, exports.useNodeProps)(nodeId, function (node, ancestors) {
        var _a;
        var parent = (0, node_1.isRow)(ancestors[0]) ? ancestors[0] : null;
        var myIndex = (_a = parent === null || parent === void 0 ? void 0 : parent.cells.findIndex(function (c) { return c.id === node.id; })) !== null && _a !== void 0 ? _a : -1;
        var cell = !(0, node_1.isRow)(node) ? node : null;
        if (!cell || myIndex < 0) {
            return null;
        }
        if (cell.inline) {
            return {
                left: 0,
                right: 0,
            };
        }
        return {
            left: myIndex > 0 ? parent.cells[myIndex - 1].size + cell.size - 1 : 0,
            right: myIndex === parent.cells.length - 1
                ? 0
                : cell.size - 1 + parent.cells[myIndex + 1].size,
        };
    });
};
exports.useCellBounds = useCellBounds;
/**
 *
 * @param nodeId a node id
 * @returns an array of nodeIds that are direct children of the given node
 */
var useNodeChildrenIds = function (nodeId) {
    return (0, exports.useNodeProps)(nodeId, function (node) {
        var _a, _b, _c, _d;
        return (0, node_1.isRow)(node)
            ? (_b = (_a = node.cells) === null || _a === void 0 ? void 0 : _a.map(function (c) { return c.id; })) !== null && _b !== void 0 ? _b : []
            : (_d = (_c = node.rows) === null || _c === void 0 ? void 0 : _c.map(function (r) { return r.id; })) !== null && _d !== void 0 ? _d : [];
    });
};
exports.useNodeChildrenIds = useNodeChildrenIds;
/**
 *
 * @param nodeId a node id
 * @returns true if node has children
 */
var useNodeHasChildren = function (nodeId) {
    return (0, exports.useNodeProps)(nodeId, function (node) {
        var _a, _b, _c, _d;
        return (0, node_1.isRow)(node)
            ? (_b = ((_a = node.cells) === null || _a === void 0 ? void 0 : _a.length) > 0) !== null && _b !== void 0 ? _b : false
            : (_d = ((_c = node.rows) === null || _c === void 0 ? void 0 : _c.length) > 0) !== null && _d !== void 0 ? _d : false;
    });
};
exports.useNodeHasChildren = useNodeHasChildren;
/**
 *
 * @param nodeId an id of a cell
 * @returns true if this cell has a configured plugin. It does not check if this plugin exists (in @see Options)
 */
var useCellHasPlugin = function (nodeId) {
    return (0, exports.useCellProps)(nodeId, function (c) { return Boolean(c.plugin); });
};
exports.useCellHasPlugin = useCellHasPlugin;
/**
 * @param parentNodeId the parent node id, or null if its the root
 * @returns all configured CellPlugin that are allowed in the given parentCellId
 */
var useAllCellPluginsForNode = function (parentNodeId) {
    var currentLang = (0, options_1.useLang)();
    var ancestors = (0, exports.useNodeProps)(parentNodeId, function (node, ancestors) {
        return __spreadArray([node], __read(ancestors), false).reverse().map(function (a) {
            var _a;
            return {
                pluginId: !a || (0, node_1.isRow)(a) ? null : (_a = a.plugin) === null || _a === void 0 ? void 0 : _a.id,
                data: !a || (0, node_1.isRow)(a) ? null : (0, getCellData_1.getCellData)(a, currentLang),
            };
        });
    });
    // pluginIdsOfAncestors is an array of ids, the last one is the
    var rootCellPlugins = (0, renderOptions_1.useRenderOption)('cellPlugins');
    return (0, react_1.useMemo)(function () {
        return (0, getAvailablePlugins_1.getAvailablePlugins)(rootCellPlugins, ancestors);
    }, [rootCellPlugins, ancestors]);
};
exports.useAllCellPluginsForNode = useAllCellPluginsForNode;
var useCellIsAllowedHere = function (nodeId) {
    var availablePlugins = (0, exports.useAllCellPluginsForNode)(nodeId);
    return (0, react_1.useCallback)(function (item) {
        var _a, _b, _c;
        if (!(item === null || item === void 0 ? void 0 : item.cell)) {
            return false;
        }
        var itemPluginId = typeof ((_a = item.cell) === null || _a === void 0 ? void 0 : _a.plugin) === 'string'
            ? item.cell.plugin
            : (_b = item.cell) === null || _b === void 0 ? void 0 : _b.plugin.id;
        var allowed = !((_c = item.cell) === null || _c === void 0 ? void 0 : _c.plugin) ||
            availablePlugins.some(function (p) { return p.id === itemPluginId; });
        return allowed;
    }, [availablePlugins]);
};
exports.useCellIsAllowedHere = useCellIsAllowedHere;
/**
 * Use this function to get the plugin of a cell.
 * @param nodeId an id of a cell
 * @returns the plugin of the given cell
 *
 */
var usePluginOfCell = function (nodeId) {
    var _a = (0, exports.useCellProps)(nodeId, function (c, ancestors) {
        var _a, _b;
        return ({
            pluginId: (_a = c === null || c === void 0 ? void 0 : c.plugin) === null || _a === void 0 ? void 0 : _a.id,
            parentNodeId: (_b = ancestors === null || ancestors === void 0 ? void 0 : ancestors[0]) === null || _b === void 0 ? void 0 : _b.id,
        });
    }), pluginId = _a.pluginId, parentNodeId = _a.parentNodeId;
    var plugins = (0, exports.useAllCellPluginsForNode)(parentNodeId);
    return plugins.find(function (p) { return p.id === pluginId; });
};
exports.usePluginOfCell = usePluginOfCell;
/**
 *
 * @param nodeId a cell id
 * @returns the raw localized data of the cell
 */
var useCellDataI18nRaw = function (nodeId) {
    return (0, exports.useCellProps)(nodeId, function (c) { return c === null || c === void 0 ? void 0 : c.dataI18n; });
};
exports.useCellDataI18nRaw = useCellDataI18nRaw;
/**
 *
 * @param nodeId a cell id
 * @param lang a language key
 * @returns the data object in the given language of the given cell
 */
var useCellData = function (nodeId, lang) {
    var currentLang = (0, options_1.useLang)();
    var theLang = lang !== null && lang !== void 0 ? lang : currentLang;
    return (0, exports.useCellProps)(nodeId, function (c) { var _a; return (_a = (0, getCellData_1.getCellData)(c, theLang)) !== null && _a !== void 0 ? _a : {}; });
};
exports.useCellData = useCellData;
/**
 *returns style and classname of a cell's inner div
 * @param nodeId a cell id
 * @param lang a language key (optionally)
 * @returns the data object in the given language of the given cell
 */
var useCellInnerDivStylingProps = function (nodeId, lang) {
    var plugin = (0, exports.usePluginOfCell)(nodeId);
    var currentLang = (0, options_1.useLang)();
    var theLang = lang !== null && lang !== void 0 ? lang : currentLang;
    return (0, exports.useCellProps)(nodeId, function (c) {
        var data = (0, getCellData_1.getCellData)(c, theLang);
        return (0, getCellStylingProps_1.getCellInnerDivStylingProps)(c, plugin, data);
    });
};
exports.useCellInnerDivStylingProps = useCellInnerDivStylingProps;
/**
 *
 * @returns [data, onChangeData] pair, with setData debouncing the propagation
 * also data is always partially updated
 * @param nodeId the id of a cell
 */
var useDebouncedCellData = function (nodeId) {
    var cellData = (0, exports.useCellData)(nodeId);
    var _a = __read((0, react_1.useState)(cellData), 2), setData = _a[1];
    var dataRef = (0, react_1.useRef)(cellData);
    var cellDataRef = (0, react_1.useRef)(cellData);
    var updateCellData = (0, nodeActions_1.useUpdateCellData)(nodeId);
    var updateCellDataDebounced = (0, react_1.useCallback)((0, lodash_debounce_1.default)(function (options) {
        cellDataRef.current = dataRef.current;
        updateCellData(dataRef.current, options);
    }, 200), [updateCellData]);
    var changed = (0, react_1.useMemo)(function () { return !(0, deepEquals_1.default)(cellData, cellDataRef.current); }, [cellData]);
    (0, react_1.useEffect)(function () {
        // changed from "outside" overwrite whatever is pending
        if (changed) {
            cellDataRef.current = cellData;
            dataRef.current = cellData;
            setData(cellData);
        }
    }, [changed, cellData]);
    var onChange = (0, react_1.useCallback)(function (partialData, options) {
        dataRef.current = __assign(__assign({}, dataRef.current), partialData);
        setData(dataRef.current);
        updateCellDataDebounced(options);
    }, [updateCellDataDebounced, setData]);
    return [dataRef.current, onChange];
};
exports.useDebouncedCellData = useDebouncedCellData;
//# sourceMappingURL=node.js.map