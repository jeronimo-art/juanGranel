"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTrashDrop = exports.useInsertNew = exports.useBlurAllCells = exports.useBlurCell = exports.useFocusCell = exports.useFocusCellById = exports.useSetDisplayReferenceNodeId = exports.useDuplicateCell = exports.useDuplicateMultipleCells = exports.useInsertAfter = exports.useDuplicateCellById = exports.useRemoveMultipleNodeIds = exports.useRemoveCell = exports.useRemoveCellById = exports.useUpdateCellData = exports.useSetLang = exports.useResizeCell = exports.useResizeCellById = exports.useSetDraft = void 0;
var react_1 = require("react");
var react_dnd_1 = require("react-dnd");
var ancestorTree_1 = require("../../utils/ancestorTree");
var cell_1 = require("../../actions/cell");
var core_1 = require("../../actions/cell/core");
var insert_1 = require("../../actions/cell/insert");
var display_1 = require("../../actions/display");
var setting_1 = require("../../actions/setting");
var reduxConnect_1 = require("../../reduxConnect");
var node_1 = require("../../types/node");
var node_2 = require("./node");
var options_1 = require("./options");
var cloneWithNewIds_1 = require("../../../core/utils/cloneWithNewIds");
var displayMode_1 = require("./displayMode");
/**
 * @param id id of a node
 * @returns function, that sets a cell in draft mode (will be invisible in readonly / preview)
 */
var useSetDraft = function (id) {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    return (0, react_1.useCallback)(function (isDraft, lang) {
        return dispatch((0, core_1.updateCellIsDraft)(id, isDraft, lang));
    }, [dispatch, id]);
};
exports.useSetDraft = useSetDraft;
/**
 * @returns function to resize a cell
 */
var useResizeCellById = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    return (0, react_1.useCallback)(function (nodeId, size) { return dispatch((0, core_1.resizeCell)(nodeId)(size)); }, [dispatch]);
};
exports.useResizeCellById = useResizeCellById;
/**
 *
 * @param id a cell id
 * @returns a function to resize the given cell
 */
var useResizeCell = function (id) {
    var resizeById = (0, exports.useResizeCellById)();
    return (0, react_1.useCallback)(function (size) { return resizeById(id, size); }, [resizeById, id]);
};
exports.useResizeCell = useResizeCell;
/**
 *
 * @returns a function to change the current language
 */
var useSetLang = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    return (0, react_1.useCallback)(function (lang) { return dispatch((0, setting_1.setLang)(lang)); }, [dispatch]);
};
exports.useSetLang = useSetLang;
/**
 *
 * @param id a cell id
 * @returns function to update the data of the given cell. Sets the data in the current language, unless options.lang is set
 */
var useUpdateCellData = function (id) {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    var currentLang = (0, options_1.useLang)();
    return (0, react_1.useCallback)(function (data, options) {
        if (options === void 0) { options = {}; }
        dispatch((0, core_1.updateCellData)(id)(data, __assign({ notUndoable: false, lang: currentLang }, options)));
    }, [dispatch, id, currentLang]);
};
exports.useUpdateCellData = useUpdateCellData;
/**
 * @returns a function to remove a cell by id
 */
var useRemoveCellById = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    return (0, react_1.useCallback)(function (id) { return dispatch((0, core_1.removeCells)([id])); }, [dispatch]);
};
exports.useRemoveCellById = useRemoveCellById;
/**
 * @param id a cell id
 * @returns a function to remove the given cell
 */
var useRemoveCell = function (id) {
    var removeById = (0, exports.useRemoveCellById)();
    return (0, react_1.useCallback)(function () { return removeById(id); }, [removeById, id]);
};
exports.useRemoveCell = useRemoveCell;
/**
 *
 * @returns a function to remove muliple nodeids
 */
var useRemoveMultipleNodeIds = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    return (0, react_1.useCallback)(function (nodeIds) {
        dispatch((0, core_1.removeCells)(nodeIds));
    }, [dispatch]);
};
exports.useRemoveMultipleNodeIds = useRemoveMultipleNodeIds;
/**
 * @returns a function that duplicates a cell
 */
var useDuplicateCellById = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    var editor = (0, options_1.useEditorStore)();
    return (0, react_1.useCallback)(function (id) { return dispatch((0, insert_1.duplicateCell)(editor.getNode(id))); }, [dispatch]);
};
exports.useDuplicateCellById = useDuplicateCellById;
var useInsertAfter = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    var insertNew = (0, exports.useInsertNew)();
    return (0, react_1.useCallback)(function (node, insertAfterNodeId) {
        if (insertAfterNodeId) {
            dispatch((0, insert_1.duplicateNode)(node, {
                insertAfterNodeId: insertAfterNodeId,
            }));
        }
        else {
            // insert at the end
            insertNew((0, cloneWithNewIds_1.cloneWithNewIds)(node));
        }
    }, [dispatch, insertNew]);
};
exports.useInsertAfter = useInsertAfter;
/**
 * @returns a function that duplicates multiple cell
 */
var useDuplicateMultipleCells = function () {
    var editor = (0, options_1.useEditorStore)();
    var insertAfter = (0, exports.useInsertAfter)();
    return (0, react_1.useCallback)(function (cellIds) {
        var node = (0, ancestorTree_1.getCommonAncestorTree)(editor, cellIds);
        var insertAfterNodeId = (0, node_1.isRow)(node)
            ? node.id
            : node.rows[node.rows.length - 1].id;
        insertAfter(node, insertAfterNodeId);
    }, [editor, insertAfter]);
};
exports.useDuplicateMultipleCells = useDuplicateMultipleCells;
/**
 * @param a cell id
 * @returns a function that duplicates the given cell
 */
var useDuplicateCell = function (id) {
    var duplicate = (0, exports.useDuplicateCellById)();
    return (0, react_1.useCallback)(function () { return duplicate(id); }, [duplicate, id]);
};
exports.useDuplicateCell = useDuplicateCell;
/**
 * experimental
 * @returns function to set the reference node id. used internally
 */
var useSetDisplayReferenceNodeId = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    var referenceId = (0, displayMode_1.useDisplayModeReferenceNodeId)();
    return (0, react_1.useCallback)(function (nodeId) {
        if (nodeId !== referenceId)
            dispatch((0, display_1.setDisplayReferenceNodeId)(nodeId));
    }, [dispatch, referenceId]);
};
exports.useSetDisplayReferenceNodeId = useSetDisplayReferenceNodeId;
/**
 * @returns a function to focus a cell by id
 */
var useFocusCellById = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    var editor = (0, options_1.useEditorStore)();
    return (0, react_1.useCallback)(function (id, scrollToCell, mode) {
        var _a, _b, _c;
        var parentCellId = (_c = (_b = (_a = editor
            .getNodeWithAncestors(id)) === null || _a === void 0 ? void 0 : _a.ancestors) === null || _b === void 0 ? void 0 : _b.find(function (node) { return !(0, node_1.isRow)(node); })) === null || _c === void 0 ? void 0 : _c.id;
        dispatch((0, display_1.setDisplayReferenceNodeId)(parentCellId));
        dispatch((0, core_1.focusCell)(id, scrollToCell, mode));
    }, [dispatch, editor]);
};
exports.useFocusCellById = useFocusCellById;
/**
 * @returns a function to focus a cell by id
 */
var useFocusCell = function (id) {
    var focusCellById = (0, exports.useFocusCellById)();
    return (0, react_1.useCallback)(function (scrollToCell, mode) {
        return focusCellById(id, scrollToCell, mode);
    }, [focusCellById]);
};
exports.useFocusCell = useFocusCell;
/**
 * @returns function to blur a cell by id
 */
var useBlurCell = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    return (0, react_1.useCallback)(function (id) {
        dispatch((0, core_1.blurCell)(id));
    }, [dispatch]);
};
exports.useBlurCell = useBlurCell;
/**
 * @returns function to blur all cells
 */
var useBlurAllCells = function () {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    return (0, react_1.useCallback)(function () {
        dispatch((0, cell_1.blurAllCells)());
    }, [dispatch]);
};
exports.useBlurAllCells = useBlurAllCells;
/**
 * @returns function to insert a cell at the end of the document or the end of the parent cell
 *
 * if the id already exists, it will move that cell
 */
var useInsertNew = function (parentCellId) {
    var dispatch = (0, reduxConnect_1.useDispatch)();
    var cellPlugins = (0, node_2.useAllCellPluginsForNode)(parentCellId);
    var editor = (0, options_1.useEditorStore)();
    var lang = (0, options_1.useLang)();
    return (0, react_1.useCallback)(function (partialCell) {
        var action = parentCellId ? insert_1.insertCellNewAsNewRow : insert_1.insertCellAtTheEnd;
        dispatch(action({
            cellPlugins: cellPlugins,
            lang: lang,
        })(partialCell, { id: parentCellId }, { focusAfter: true }));
    }, [dispatch, editor, cellPlugins, parentCellId]);
};
exports.useInsertNew = useInsertNew;
/**
 * used for the trash target
 */
var useTrashDrop = function () {
    var removeCell = (0, exports.useRemoveCellById)();
    return (0, react_dnd_1.useDrop)({
        accept: 'cell',
        collect: function (monitor) { return ({
            isHovering: monitor.isOver({ shallow: true }),
        }); },
        drop: function (item, monitor) { return removeCell(item.cell.id); },
    });
};
exports.useTrashDrop = useTrashDrop;
//# sourceMappingURL=nodeActions.js.map