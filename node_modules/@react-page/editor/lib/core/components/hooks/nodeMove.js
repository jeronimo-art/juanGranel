"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMoveNodeRight = exports.useMoveNodeLeft = exports.useMoveNodeDown = exports.useMoveNodeUp = exports.getTargetIndexForUpAndDownMove = void 0;
var react_1 = require("react");
var types_1 = require("../../../core/types");
var displayMode_1 = require("./displayMode");
var dragDropActions_1 = require("./dragDropActions");
var node_1 = require("./node");
var findSiblingRow_1 = require("./utils/findSiblingRow");
var getTargetIndexForUpAndDownMove = function (currentRowLength, targetRowLength, myIndex) {
    var factor = (targetRowLength + 1) / currentRowLength;
    var target = myIndex * factor;
    var wasLast = myIndex === currentRowLength - 1;
    var index = wasLast
        ? targetRowLength - 1
        : Math.min(Math.floor(target), targetRowLength - 1);
    return {
        action: wasLast || target - index > 0.5 ? 'rightOf' : 'leftOf',
        index: index,
    };
};
exports.getTargetIndexForUpAndDownMove = getTargetIndexForUpAndDownMove;
var useMoveCellAction = function (nodeId, selector) {
    var actions = (0, dragDropActions_1.useDropActions)(nodeId);
    var _a = (0, node_1.useNodeProps)(nodeId, selector), node = _a.node, targetNodeId = _a.targetNodeId, action = _a.action;
    var isEditMode = (0, displayMode_1.useIsEditMode)();
    var hoverTarget = (0, node_1.useNodeAsHoverTarget)(targetNodeId);
    return (0, react_1.useMemo)(function () {
        // skip if no target
        if (!hoverTarget) {
            return null;
        }
        return function () {
            actions[action](node, hoverTarget, { focusAfter: isEditMode });
        };
    }, [isEditMode, actions, hoverTarget, node]);
};
var useMoveNodeUp = function (nodeId) {
    return useMoveCellAction(nodeId, function (node, ancestors) {
        var _a, _b, _c;
        // if node is not the only sibling in the row, put it above the row to stretch it
        var rowWithMoreThanOneCell = searchAncestorRows(ancestors, function (row) {
            if ((row === null || row === void 0 ? void 0 : row.cells.length) > 1) {
                return row;
            }
            return null;
        }, 
        // breakIf
        // break if a parent row is not the first row of a cell, because then we would "jump" a parent
        function (row, parentOfRow) {
            var _a;
            return (parentOfRow &&
                ((_a = parentOfRow === null || parentOfRow === void 0 ? void 0 : parentOfRow.rows) === null || _a === void 0 ? void 0 : _a.findIndex(function (r) { return r.id === row.id; })) !== 0);
        });
        if (rowWithMoreThanOneCell) {
            return {
                action: 'above',
                node: node,
                targetNodeId: rowWithMoreThanOneCell === null || rowWithMoreThanOneCell === void 0 ? void 0 : rowWithMoreThanOneCell.id,
            };
        }
        var parent = (0, types_1.isRow)(ancestors === null || ancestors === void 0 ? void 0 : ancestors[0]) ? ancestors === null || ancestors === void 0 ? void 0 : ancestors[0] : null;
        // else move it into previous row as sibling
        var myIndexInParent = parent === null || parent === void 0 ? void 0 : parent.cells.findIndex(function (c) { return c.id === nodeId; });
        var previousRow = (0, findSiblingRow_1.findSiblingRow)(nodeId, ancestors, 'previous');
        var previousRowCells = previousRow === null || previousRow === void 0 ? void 0 : previousRow.cells;
        var _d = (0, exports.getTargetIndexForUpAndDownMove)((_b = (_a = parent === null || parent === void 0 ? void 0 : parent.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0, previousRowCells === null || previousRowCells === void 0 ? void 0 : previousRowCells.length, myIndexInParent), index = _d.index, action = _d.action;
        return {
            action: action,
            node: node,
            targetNodeId: (_c = previousRowCells === null || previousRowCells === void 0 ? void 0 : previousRowCells[index]) === null || _c === void 0 ? void 0 : _c.id,
        };
    });
};
exports.useMoveNodeUp = useMoveNodeUp;
var useMoveNodeDown = function (nodeId) {
    return useMoveCellAction(nodeId, function (node, ancestors) {
        var _a, _b, _c;
        // if node is not the only sibling in the row, put it below the row to stretch it
        var rowWithMoreThanOneCell = searchAncestorRows(ancestors, function (row) {
            if ((row === null || row === void 0 ? void 0 : row.cells.length) > 1) {
                return row;
            }
            return null;
        }, 
        // breakIf
        // break if a parent row is not the last row of a cell, because then we would "jump" a parent
        function (row, parentOfRow) {
            var _a;
            return (parentOfRow &&
                ((_a = parentOfRow === null || parentOfRow === void 0 ? void 0 : parentOfRow.rows) === null || _a === void 0 ? void 0 : _a.findIndex(function (r) { return r.id === row.id; })) !==
                    parentOfRow.rows.length - 1);
        });
        if (rowWithMoreThanOneCell) {
            return {
                action: 'below',
                node: node,
                targetNodeId: rowWithMoreThanOneCell === null || rowWithMoreThanOneCell === void 0 ? void 0 : rowWithMoreThanOneCell.id,
            };
        }
        // else move it into next row as sibling
        var parent = (0, types_1.isRow)(ancestors === null || ancestors === void 0 ? void 0 : ancestors[0]) ? ancestors === null || ancestors === void 0 ? void 0 : ancestors[0] : null;
        var nextRow = (0, findSiblingRow_1.findSiblingRow)(nodeId, ancestors, 'next');
        var myIndexInParent = parent === null || parent === void 0 ? void 0 : parent.cells.findIndex(function (c) { return c.id === nodeId; });
        var nextRowCells = nextRow === null || nextRow === void 0 ? void 0 : nextRow.cells;
        var _d = (0, exports.getTargetIndexForUpAndDownMove)((_b = (_a = parent === null || parent === void 0 ? void 0 : parent.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0, nextRowCells === null || nextRowCells === void 0 ? void 0 : nextRowCells.length, myIndexInParent), index = _d.index, action = _d.action;
        return {
            action: action,
            node: node,
            targetNodeId: (_c = nextRowCells === null || nextRowCells === void 0 ? void 0 : nextRowCells[index]) === null || _c === void 0 ? void 0 : _c.id,
        };
    });
};
exports.useMoveNodeDown = useMoveNodeDown;
var searchAncestorRows = function (ancestors, find, breakIf) {
    for (var i = 0; i < ancestors.length; i++) {
        var parent_1 = ancestors[i];
        var greatParent = ancestors[i + 1];
        var parentRow = (0, types_1.isRow)(parent_1) ? parent_1 : null;
        var greatParentCell = greatParent && (0, types_1.isRow)(greatParent) ? null : greatParent;
        if (parentRow) {
            var found = find(parentRow, greatParentCell);
            if (found)
                return found;
        }
        if (breakIf && breakIf(parentRow, greatParentCell)) {
            return null;
        }
    }
    return null;
};
var useMoveNodeLeft = function (nodeId) {
    return useMoveCellAction(nodeId, function (node, ancestors) {
        var previousSibling = searchAncestorRows(ancestors, function (row) {
            var myIndexInParent = row === null || row === void 0 ? void 0 : row.cells.findIndex(function (c) { return c.id === nodeId; });
            return row === null || row === void 0 ? void 0 : row.cells[myIndexInParent - 1];
        });
        return {
            action: 'leftOf',
            node: node,
            targetNodeId: previousSibling === null || previousSibling === void 0 ? void 0 : previousSibling.id,
        };
    });
};
exports.useMoveNodeLeft = useMoveNodeLeft;
var useMoveNodeRight = function (nodeId) {
    return useMoveCellAction(nodeId, function (node, ancestors) {
        var nextSibling = searchAncestorRows(ancestors, function (row) {
            var myIndexInParent = row === null || row === void 0 ? void 0 : row.cells.findIndex(function (c) { return c.id === nodeId; });
            return row === null || row === void 0 ? void 0 : row.cells[myIndexInParent + 1];
        });
        return {
            action: 'rightOf',
            node: node,
            targetNodeId: nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.id,
        };
    });
};
exports.useMoveNodeRight = useMoveNodeRight;
//# sourceMappingURL=nodeMove.js.map